import "module:std" as std
import "module:spotube_plugin" as spotube
import { MbConverter, LbConverter } from "./converter.ht"
import { UserEndpoint } from "./user.ht"

var HttpClient = std.HttpClient
var HttpResponse = std.HttpResponse
var RequestOptions = std.RequestOptions
var LocalStorage = spotube.LocalStorage

class ArtistEndpoint {
  var lbApi: HttpClient
  var mbApi: HttpClient
  final username: string

  construct (this.lbApi, this.mbApi, this.username)

  static fun getArtistImages(
    client: HttpClient,
    artistWikiDataUrl: string
  ) {
    var wikidataId = artistWikiDataUrl.split("/")?.last

    return client.get_req(
      "https://www.wikidata.org/w/api.php",
      queryParameters: {
        format: "json",
        props: "claims",
        ids: wikidataId,
        action: "wbgetentities",
      }.toJson()
    ).then((res){
      var data = res.data
      var imageName = data["entities"][wikidataId]["claims"]["P18"][0]["mainsnak"]["datavalue"]["value"]

      return client.get_req(
        "https://commons.wikimedia.org/w/api.php",
        queryParameters: {
          action: "query",
          titles: "File:${imageName}",
          prop: "imageinfo",
          iiprop: "url",
          format: "json"
        }.toJson()
      ).then((res)=>res.data["query"]["pages"].values.first["imageinfo"].first["url"])
    })
    .then((imageUrl){
      return [
        {
          url: imageUrl,
          width: 500,
          height: 500,
        }.toJson()
      ]
    })
  }

  fun getArtist(id: string) {
    return mbApi.get_req(
      "/artist/${id}",
      queryParameters: {
        fmt: "json",
        inc: "url-rels"
      }.toJson()
    ).then((res){
      var data = res.data

      var wikidataUrl = data["relations"].firstWhere(
        (relation) => relation["type"] == "wikidata",
        orElse: () => null
      )?["url"]?["resource"]

      return getArtistImages(mbApi, wikidataUrl).then((images){
        var artist = MbConverter.artists([data]).first
        artist["images"] = images
        return artist
      })
    })
  }

  fun topTracks(id: string, {limit: int, offset: int}) {
    return mbApi.get_req(
      "/release",
      queryParameters: {
        fmt: "json",
        artist: id,
        limit: 5,
        offset: 0,
        inc: "artist-credits+recordings+ratings+isrcs+release-groups"
      }.toJson()
    ).then((res){
      var data = res.data

      var tracks = data["releases"].expand((release){
        var medias = release["media"].toList()
        release["media"] = null

        return medias.expand((media){
          return media["tracks"].map((track){
            track["recording"]["releases"] = [release]
            return track["recording"]
          }).toList()
        }).toList()
      }).toList()

      // Remove duplicates
      for (var i = 0; i < tracks.length; i++) {
        for (var j = i + 1; j < tracks.length; j++) {
          if (tracks[i]["title"] == tracks[j]["title"]) {
            tracks.removeAt(j)
            j--
          }
        }
      }

      tracks.sort((a, b) {
        var aVoteCount = a["rating"]["votes-count"] ?? 0
        var bVoteCount = b["rating"]["votes-count"] ?? 0
        var aRating = a["rating"]["value"] ?? 0
        var bRating = b["rating"]["value"] ?? 0

        var aAvg = aVoteCount > 0 ? aRating / aVoteCount : 0
        var bAvg = bVoteCount > 0 ? bRating / bVoteCount : 0

        return bAvg.compareTo(aAvg)
      })

      var items = MbConverter.recordings(tracks)

      return {
        limit: limit ?? 10,
        nextOffset: null,
        total: items.length,
        hasMore: false,
        items: items
      }.toJson()
    })
  }

  fun albums(id: string, {offset: int, limit: int}) {
    return mbApi.get_req(
      "/release",
      queryParameters: {
        fmt: "json",
        artist: id,
        limit: limit ?? 20,
        offset: offset ?? 0,
        inc: "artist-credits+release-groups"
      }.toJson()
    ).then((res){
      var data = res.data

      var items = MbConverter.releases(data["releases"])
      var hasMore = data["releases"].length < (limit ?? 20)

      return {
        limit: limit ?? 20,
        nextOffset: hasMore ? data["release-offset"] + (limit ?? 20) : null,
        total: data["release-count"],
        hasMore: hasMore,
        items: items
      }.toJson()
    })
  }

  fun save(artistIds: List) {
    return UserEndpoint.internalIsSavedArtists(lbApi, mbApi, username, artistIds)
      .then((matches){
        if (matches.any((match) => match)) {
          throw "Artists already saved"
        }

        return UserEndpoint.getOrCreateArtistPlaylist(lbApi, username)
        .then((playlistId) {
          var tracksFutures = artistIds.map((artistId){
            return mbApi.get_req(
              "/recording",
              queryParameters: {
                "fmt": "json",
                "artist": artistId,
                "limit": 1,
                "offset": 0,
              }.toJson()
            ).then((res)=>res.data["recordings"].first["id"])
          }).toList()

          return Future.wait(tracksFutures)
          .then((tracks){            
            var data = {
              playlist: {
                  track: tracks.map((track) {
                    return {
                      identifier: "https://musicbrainz.org/recording/${track}"
                    }
                  }).toList()
              }
            }

            return lbApi.post(
              "/playlist/${playlistId}/item/add",
              data: data.toJson(),
              options: RequestOptions(
                headers: {
                  "Content-Type": "application/json"
                }.toJson()
              )
            ).then((res){
              return LocalStorage.setString(
                "saved_artist_ids",
                artistIds.join(",")
              ).then((_) => res.data)
            })
          })
        })
      })
  }

  fun unsave(artistIds: List) {
    assert(artistIds.isNotEmpty, "Artist IDs cannot be empty.")
    
    return UserEndpoint.getOrCreateArtistPlaylist(lbApi, username)
    .then((playlistId) {
      return UserEndpoint.getPlaylistTracks(playlistId, lbApi)
      .then((tracks) {
        var savedArtistIds = tracks
          .map((t) => t["extension"]["https://musicbrainz.org/doc/jspf#track"]["additional_metadata"]["artists"][0]["artist_mbid"])
          .toList()

        if(artistIds.any((id) => !savedArtistIds.contains(id))) {
          throw "Some artists are not saved."
        }

        var trackIndexes = []
        for(var i = 0; i < tracks.length; i++) {
          var track = tracks[i]
          var trackArtistId = track["extension"]["https://musicbrainz.org/doc/jspf#track"]["additional_metadata"]["artists"][0]["artist_mbid"]
          if(artistIds.contains(trackArtistId)) {
            trackIndexes.add(i)
          }
        }

        if(trackIndexes.isEmpty) {
          throw "No artist to unsave."
        }
        
        var deleteRequests = trackIndexes.map((index) {
          return lbApi.post(
            "/playlist/${playlistId}/item/delete",
            data: {
              index: index,
              count: 1
            }.toJson(),
            options: RequestOptions(
              headers: {
                "Content-Type": "application/json"
              }.toJson()
            )
          ).then((res) => res.data)
        }).toList()

        return Future.wait(deleteRequests).then((res){
          return LocalStorage.getString("saved_artist_ids").then((savedIds) {
            var remainingIds = savedIds.split(",").where((id) => !artistIds.contains(id)).join(",")
            return LocalStorage.setString("saved_artist_ids", remainingIds).then((_) {
              return res
            })
          })
        })
      })
    })
  }
}

export { ArtistEndpoint }