import "module:std" as std
import "module:spotube_plugin" as spotube
import { MbConverter } from "./converter.ht"

var HttpClient = std.HttpClient
var HttpResponse = std.HttpResponse
var LocalStorage = spotube.LocalStorage

class UserEndpoint {
  var lbApi: HttpClient
  var mbApi: HttpClient
  final username: string

  construct (this.lbApi, this.mbApi, this.username)
  
  fun me() {
    return Future.value(MbConverter.user(username))
  }

  fun savedTracks({ offset: int, limit: int }) {
    return lbApi.get_req(
      "/feedback/user/${username}/get-feedback",
      queryParameters: {
        score: "1",
        count: limit ?? 20,
        offset: offset ?? 0,
      }.toJson()
    )
    .then((res){
      var data = res.data
      var hasMore = data["feedback"].length >= (limit ?? 20)
      var mbids = data["feedback"].map((f) => "rid:${f["recording_mbid"]}").join(" OR ")

      return mbApi.get_req(
        "/recording",
        queryParameters: {
          query: mbids,
          limit: data["feedback"].length,
          fmt: "json"
        }.toJson()
      ).then((res){
        var recordings = res.data["recordings"] ?? []
        
        return {
          limit: data["count"], 
          nextOffset: hasMore ? data["offset"] + data["count"] : null,
          total: data["total_count"],
          hasMore: hasMore,
          items: MbConverter.recordings(recordings)
        }.toJson()
      })
    })
  }

  fun savedPlaylists({ offset: int, limit: int }) {
    return lbApi.get_req(
      "/user/${username}/playlists",
      queryParameters: {
        count: limit ?? 20,
        offset: offset ?? 0,
      }.toJson()
    ).then((res){
      var data = res.data
      var hasMore = data["playlists"].length >= (limit ?? 20)

      var items = MbConverter.playlists(data["playlists"])
      
      return {
        limit: data["count"],
        nextOffset: hasMore ? data["offset"] + data["count"] : null,
        total: data["playlist_count"],
        hasMore: hasMore,
        items: items
      }.toJson()
    })
  }

  fun getAlbumsFromPlaylist(playlistId: string) -> Future {
    return lbApi.get_req("/playlist/${playlistId}").then((res){
      var data = res.data
      var albumIds = data["playlist"]["track"]
        .map((t) => "reid:${t["extension"]["https://musicbrainz.org/doc/jspf#track"]["additional_metadata"]["caa_release_mbid"]}")
        .join(" OR ")

      if(albumIds.isEmpty) {
        return {
          limit: limit ?? 20,
          nextOffset: null, // No pagination for albums
          total: 0,
          hasMore: false,
          items: []
        }.toJson()
      }

      return mbApi.get_req(
        "/release",
        queryParameters: {
          query: albumIds,
          limit: data["playlist"]["track"].length,
          fmt: "json"
        }.toJson()
      ).then((res){
        var items = MbConverter.releases(res.data["releases"])
        var ids = items.map((i) => i["id"]).join(",")

        LocalStorage.setString("saved_album_ids", ids)

        return {
          limit: 20,
          nextOffset: null, // No pagination for albums
          total: data["playlist"]["track"].length,
          hasMore: false,
          items: items
        }.toJson()
      })
    })
  }

  fun savedAlbums({ offset: int, limit: int }) {
    var name = "${username} saved albums by Spotube"

    return LocalStorage.getString("saved_album_playlist_id")
    .then((savedPlaylistId) {
      if(savedPlaylistId == null) {
        return lbApi.get_req(
          "/user/${username}/playlists/search",
          queryParameters: {
            count: 1,
            offset: 0,
            query: name
          }.toJson()
        ).then((res) {
          var userPlaylists = res.data["playlists"]
            .where((p)=>p["playlist"]["creator"] == username && p["playlist"]["title"] == name)
            .toList()

          var data = Future.value(
            userPlaylists.isNotEmpty ? 
              userPlaylists[0]["playlist"]["identifier"].split("/").last 
              : null
          )
          
          if(userPlaylists.isEmpty) {
            // We have to create the playlist first
            data = lbApi.post(
              "/playlist/create",
              data: {
                playlist: {
                  title: name,
                  annotation: "This playlist contains all albums saved by ${username} on Spotube. Autogenerated. Do not edit.",
                  extension: {
                    "https://musicbrainz.org/doc/jspf#playlist": {
                      collaborators: [],
                      public: false,
                    },
                  },
                }
              }.toJson()
            ).then((res)=>res.data["playlist_mbid"])
          }

          return data.then((playlistId) {
            return LocalStorage.setString("saved_album_playlist_id", playlistId)
            .then((_)=> getAlbumsFromPlaylist(playlistId))
          })
        })
      }

      return getAlbumsFromPlaylist(savedPlaylistId)
    })
  }

  fun getArtistsFromPlaylist(playlistId: string) -> Future {
    return lbApi.get_req("/playlist/${playlistId}").then((res){
      var data = res.data
      var artistIds = data["playlist"]["track"]
        .map((t) => "arid:${t["extension"]["https://musicbrainz.org/doc/jspf#track"]["additional_metadata"]["artists"][0]["artist_mbid"]}")
        .join(" OR ")

      if(artistIds.isEmpty) {
        return {
          limit: limit ?? 20,
          nextOffset: null, // No pagination for albums
          total: 0,
          hasMore: false,
          items: []
        }.toJson()
      }

      return mbApi.get_req(
        "/artist",
        queryParameters: {
          query: artistIds,
          limit: data["playlist"]["track"].length,
          fmt: "json"
        }.toJson()
      ).then((res){
        var items = MbConverter.artists(res.data["artists"])

        var ids = items.map((i) => i["id"]).join(",")

        LocalStorage.setString("saved_artist_ids", ids)

        return {
          limit: 20,
          nextOffset: null, // No pagination for albums
          total: data["playlist"]["track"].length,
          hasMore: false,
          items: items
        }.toJson()
      })
    })
  }

  fun savedArtists({ offset: int, limit: int }) {
    var name = "${username} saved artists by Spotube"

    return LocalStorage.getString("saved_artist_playlist_id").then((savedPlaylistId){
      if(savedPlaylistId == null) {
        return lbApi.get_req(
          "/user/${username}/playlists/search",
          queryParameters: {
            count: 1,
            offset: 0,
            query: name
          }.toJson()
        ).then((res) {
          var userPlaylists = res.data["playlists"]
            .where((p)=>p["playlist"]["creator"] == username && p["playlist"]["title"] == name)
            .toList()

          var data = Future.value(
            userPlaylists.isNotEmpty ? 
              userPlaylists[0]["playlist"]["identifier"].split("/").last 
              : null
          )
          
          if(userPlaylists.isEmpty) {
            // We have to create the playlist first
            data = lbApi.post(
              "/playlist/create",
              data: {
                playlist: {
                  title: name,
                  annotation: "This playlist contains all artist saved by ${username} on Spotube. Autogenerated. Do not edit.",
                  extension: {
                    "https://musicbrainz.org/doc/jspf#playlist": {
                      collaborators: [],
                      public: false,
                    },
                  },
                }
              }.toJson()
            ).then((res)=>res.data["playlist_mbid"])
          }

          return data.then((playlistId){
            return LocalStorage.setString("saved_artist_playlist_id", playlistId)
              .then((_)=> getArtistsFromPlaylist(playlistId))
          })
        })
      }

      return getArtistsFromPlaylist(savedPlaylistId)
    })
  }

  fun isSavedPlaylist(playlistId: string) { // Future<bool>
    return lbApi.get_req(
      "/playlist/${playlistId}",
      queryParameters: {
        fetch_metadata: false
      }.toJson()
    ).then((res) {
      var data = res.data
      var creator = data["playlist"]["creator"] ?? data["playlist"]["extension"]["https://musicbrainz.org/doc/jspf#playlist"]["creator"]

      return creator == username
    })
  }

  fun isSavedTracks(trackIds: List) { // Future<List<bool>>
    return lbApi.post(
      "/feedback/user/${username}/get-feedback-for-recordings",
      data: {
        recording_mbids: trackIds
      }.toJson()
    ).then((res){
      var data = res.data

      return trackIds.map((id){
        var r = data["feedback"].where((f)=>f["recording_mbid"] == id).first

        return r["score"] == 1
      }).toList()
    })
  }

  fun isSavedAlbums(albumIds: List) { // Future<List<bool>>
    return LocalStorage.getString("saved_album_ids").then((savedAlbumIds) {
      if(savedAlbumIds == null) {
        return savedAlbums().then((albums){
          var saves =  albums["items"].map((album) => albumIds.contains(album["id"])).toList()

          return saves
        })
      }

      var savedIds = savedAlbumIds.split(",")
      return albumIds.map((id) => savedIds.contains(id)).toList()
    })
  }

  fun isSavedArtists(artistIds: List) { // Future<List<bool>>
    return LocalStorage.getString("saved_artist_ids").then((savedArtistIds) {
      if(savedArtistIds == null) {
        return savedArtists().then((artists){
          var saves =  artists["items"].map((artist) => artistIds.contains(artist["id"])).toList()

          return saves
        })
      }

      var savedIds = savedArtistIds.split(",")
      return artistIds.map((id) => savedIds.contains(id)).toList()
    })
  }
}

export { UserEndpoint }